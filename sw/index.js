/* global self */
import { precacheAndRoute } from 'workbox-precaching'
import { offlineFallback } from 'workbox-recipes'
import { setDefaultHandler } from 'workbox-routing'
import { NetworkOnly } from 'workbox-strategies'
import { enable } from 'workbox-navigation-preload'

import manifest from './precache-manifest.json'
import ServiceWorkerStorage from 'serviceworker-storage'
import { DELETE_SUBSCRIPTION, STORE_SUBSCRIPTION } from '@/components/serviceworker'

// we store existing push subscriptions for the onpushsubscriptionchange event
const storage = new ServiceWorkerStorage('sw:storage', 1)

// comment out to enable workbox console logs
self.__WB_DISABLE_DEV_LOGS = true

// preloading improves startup performance
// https://developer.chrome.com/docs/workbox/modules/workbox-navigation-preload/
enable()

// ignore precache manifest generated by InjectManifest
// they statically check for the presence of this variable
console.log(self.__WB_MANIFEST)
// precache the manifest we generated ourselves
precacheAndRoute(manifest)

// immediately replace existing service workers with this one
// (no wait until this one becomes active)
self.addEventListener('install', () => self.skipWaiting())

// Using network-only as the default strategy ensures that we fallback
// to the browser as if the service worker wouldn't exist.
// The browser may use own caching (HTTP cache).
// Also, the offline fallback only works if request matched a route
setDefaultHandler(new NetworkOnly({
  plugins: [{
    fetchDidFail: async (args) => {
      //  tell us why a request failed in dev
      // process.env.NODE_ENV !== 'production' && console.log('fetch did fail', ...args)
    },
    fetchDidSucceed: async ({ request, response, event, state }) => {
      if (
        response.ok &&
        request.headers.get('x-nextjs-data') &&
        response.headers.get('x-nextjs-matched-path') &&
        response.headers.get('content-type') === 'application/json' &&
        response.headers.get('content-length') === '2' &&
        response.status === 200) {
        console.log('service worker detected a successful yet empty nextjs SSR data response')
        console.log('nextjs has a bug where it returns a 200 with empty data when it should return a 404')
        console.log('see https://github.com/vercel/next.js/issues/56852')
        console.log('HACK ... intercepting response and returning 404')

        const headers = new Headers(response.headers)
        headers.delete('x-nextjs-matched-path')
        headers.delete('content-type')
        headers.delete('content-length')
        return new Response(null, {
          status: 404,
          statusText: 'Not Found',
          headers,
          ok: false
        })
      }
      return response
    }
  }]
}))

// This won't work in dev because pages are never cached.
// See https://github.com/vercel/next.js/blob/337fb6a9aadb61c916f0121c899e463819cd3f33/server/render.js#L181-L185
offlineFallback({ pageFallback: '/offline' })

self.addEventListener('push', function (event) {
  async function onPush () {
    let payload

    try {
      payload = event.data?.json()
      if (!payload) {
        throw new Error('no payload in push event')
      }
    } catch (err) {
      // we show a default nofication on any error because we *must* show a notification
      // else the browser will show one for us or worse, remove our push subscription
      await self.registration.showNotification(
        // TODO: funny message as easter egg?
        // example: "dude i'm bugging, that's wild" from https://www.youtube.com/watch?v=QsQLIaKK2s0&t=176s but in wild west theme?
        'something went wrong',
        { icon: '/icons/icon_x96.png' }
      )
      return
    }

    await self.navigator.setAppBadge?.()
    await self.registration.showNotification(payload.title, payload.options)
  }
  event.waitUntil(onPush())
})

self.addEventListener('notificationclick', function (event) {
  async function onNotificationClick () {
    const url = event.notification.data?.url
    if (url) {
      // TODO: try to focus existing client first?
      // see https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/notificationclick_event#examples?
      await self.clients.openWindow(url)
    }
    event.notification.close()
  }
  event.waitUntil(onNotificationClick())
})

self.addEventListener('pushsubscriptionchange', function (event) {
  // https://medium.com/@madridserginho/how-to-handle-webpush-api-pushsubscriptionchange-event-in-modern-browsers-6e47840d756f
  // https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/pushsubscriptionchange_event
  async function onPushSubscriptionChange () {
    let { oldSubscription, newSubscription } = event

    // fallbacks since browser may not set oldSubscription and newSubscription
    oldSubscription ??= await storage.getItem('subscription')
    newSubscription ??= await self.registration.pushManager.getSubscription()
    if (!newSubscription || oldSubscription?.endpoint === newSubscription.endpoint) {
      // no subscription exists at the moment or subscription did not change
      return
    }

    // convert keys from ArrayBuffer to string
    newSubscription = JSON.parse(JSON.stringify(newSubscription))

    // save new subscription on server
    await fetch('/api/graphql', {
      method: 'POST',
      headers: {
        'Content-type': 'application/json'
      },
      body: JSON.stringify({
        query: `
          mutation savePushSubscription(
            $endpoint: String!,
            $p256dh: String!,
            $auth: String!,
            $oldEndpoint: String!
          ) {
            savePushSubscription(
              endpoint: $endpoint,
              p256dh: $p256dh,
              auth: $auth,
              oldEndpoint: $oldEndpoint
            ) {
              id
            }
          }`,
        variables: {
          endpoint: newSubscription.endpoint,
          p256dh: newSubscription.keys.p256dh,
          auth: newSubscription.keys.auth,
          oldEndpoint: oldSubscription?.endpoint
        }
      })
    })

    // save new subscription on client
    await storage.setItem('subscription', newSubscription)
  }
  event.waitUntil(onPushSubscriptionChange())
})

self.addEventListener('message', function (event) {
  async function onMessage () {
    if (event.data.action === STORE_SUBSCRIPTION) {
      await storage.setItem('subscription', { ...event.data.subscription, swVersion: 2 })
    }
    if (event.data.action === DELETE_SUBSCRIPTION) {
      await storage.removeItem('subscription')
    }
  }
  event.waitUntil(onMessage())
})
